The experiment I was performing is solving the fractional knapsack problem. I used a greedy solution to this problem and wrote it in python. Using explanation of the greedy solution to this problem in the textbook I wrote up the code for it. I also felt like the textbook didnt give everything I needed so I was able to look at further explanations of the greedy algorithms for a problem like this online. Since the input files were already sorted by the ratio I just had to pull the data from the files and put it in the correct places. I used a class to create objects for each item that kept their weight and values. I used the example data sets created along with other ones that I created myself in txt files in which I sorted the data in non-increasing order by the ratio of vi/wi.
	With this Greedy Algorithm, the data is already sorted by the ratio when its inputted, so we add all of the highest ratio items until one does not fit all the way and then we add a fraction of the last one. Given this explanation, we would assume that this will run very fast because not much comparison has to be done. We just check if the weight of the item is less that the total weight we have left and then add it if it is. If the weight is more than we have space left for, we only add the fraction of it that fits. For most of the small data sets were using here I would assume that algorithm is going to run in less than a second. I had also tested my code on sets with 30 or more items and it always runs extremely fast. I think greedy solution works very well for this problem and allows it to be solved very efficiently. As soon as the input is already sorted by ratio it makes it extremely easy for the function to run through and add values to the knapsack. I think this algorithm ran just as smoothly and as fast as I predicted it to. I know this is what i expected since n is not that big and it is hard to compare such small times. I donâ€™t think I encountered anything strange. For one of the times I ran the code for n being 3 it ran in 7.5e-7 whereas I ran one with n being 15 with larger numbers in 5.3e-7 which surprised me that ran faster. I think its more difficult to interpret results since n is never going to be that big testing these so it hard to see that much of a difference in run time if were talking about fractions of a second.
	As soon as you run my program, type in just a text file with the .txt at the end with no white space. The program with read through that file and output code on the console. The user does not need to enter anything else while it is running. 
	I started off building the code by testing out reading the files with different readline strategies. After I gathered this data I put it into lists and then had to create objects from the two lists.  I then constructed the code with the function and class that would handle the file data. Lastly I was focusing on how to print everything out with my results from the function. 

# Fractional-Knapsack-Problem
